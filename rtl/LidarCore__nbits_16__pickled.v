//-------------------------------------------------------------------------
// LidarCore__nbits_16.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component EuclideanDistSq3D Definition
// At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py

module EuclideanDistSq3D__nbits_16
(
  input  logic [0:0] clk ,
  output logic [33:0] out_dist_sq ,
  input  logic [0:0] reset ,
  input  logic [15:0] x1 ,
  input  logic [15:0] x2 ,
  input  logic [15:0] y1 ,
  input  logic [15:0] y2 ,
  input  logic [15:0] z1 ,
  input  logic [15:0] z2 
);
  logic [15:0] __tmpvar__calc_logic_dx;
  logic [15:0] __tmpvar__calc_logic_dy;
  logic [15:0] __tmpvar__calc_logic_dz;
  logic [33:0] __tmpvar__calc_logic_dx_w;
  logic [33:0] __tmpvar__calc_logic_dy_w;
  logic [33:0] __tmpvar__calc_logic_dz_w;

  // PyMTL Update Block Source
  // At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py:43
  // @update
  // def calc_logic():
  //     # Coordinate differences
  //     dx = s.x1 - s.x2
  //     dy = s.y1 - s.y2
  //     dz = s.z1 - s.z2
  // 
  //     # Sign extend before multiplication
  //     dx_w = sext(dx, WideType)
  //     dy_w = sext(dy, WideType)
  //     dz_w = sext(dz, WideType)
  // 
  //     # Squared Euclidean distance
  //     s.out_dist_sq @= (dx_w * dx_w) + (dy_w * dy_w) + (dz_w * dz_w)
  
  always_comb begin : calc_logic
    __tmpvar__calc_logic_dx = x1 - x2;
    __tmpvar__calc_logic_dy = y1 - y2;
    __tmpvar__calc_logic_dz = z1 - z2;
    __tmpvar__calc_logic_dx_w = { { 18 { __tmpvar__calc_logic_dx[15] } }, __tmpvar__calc_logic_dx };
    __tmpvar__calc_logic_dy_w = { { 18 { __tmpvar__calc_logic_dy[15] } }, __tmpvar__calc_logic_dy };
    __tmpvar__calc_logic_dz_w = { { 18 { __tmpvar__calc_logic_dz[15] } }, __tmpvar__calc_logic_dz };
    out_dist_sq = ( ( __tmpvar__calc_logic_dx_w * __tmpvar__calc_logic_dx_w ) + ( __tmpvar__calc_logic_dy_w * __tmpvar__calc_logic_dy_w ) ) + ( __tmpvar__calc_logic_dz_w * __tmpvar__calc_logic_dz_w );
  end

endmodule


// PyMTL Component Voxelizer Definition
// At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py

module Voxelizer__nbits_16__voxel_bits_4
(
  input  logic [0:0] clk ,
  input  logic [15:0] in_x ,
  input  logic [15:0] in_y ,
  input  logic [15:0] in_z ,
  output logic [15:0] out_x ,
  output logic [15:0] out_y ,
  output logic [15:0] out_z ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py:20
  // @update
  // def comb_logic():
  //     # Snap coordinates to voxel grid
  //     s.out_x @= (s.in_x >> s.shift_amt) << s.shift_amt
  //     s.out_y @= (s.in_y >> s.shift_amt) << s.shift_amt
  //     s.out_z @= (s.in_z >> s.shift_amt) << s.shift_amt
  
  always_comb begin : comb_logic
    out_x = ( in_x >> 3'd4 ) << 3'd4;
    out_y = ( in_y >> 3'd4 ) << 3'd4;
    out_z = ( in_z >> 3'd4 ) << 3'd4;
  end

endmodule


// PyMTL Component LidarCore Definition
// At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py

module LidarCore__nbits_16
(
  input  logic [15:0] c1_x ,
  input  logic [15:0] c1_y ,
  input  logic [15:0] c1_z ,
  input  logic [15:0] c2_x ,
  input  logic [15:0] c2_y ,
  input  logic [15:0] c2_z ,
  input  logic [0:0] clk ,
  input  logic [15:0] floor_thresh ,
  input  logic [15:0] in_x ,
  input  logic [15:0] in_y ,
  input  logic [15:0] in_z ,
  output logic [0:0] out_cluster ,
  output logic [0:0] out_valid ,
  input  logic [0:0] reset 
);
  //-------------------------------------------------------------
  // Component dist1
  //-------------------------------------------------------------

  logic [0:0] dist1__clk;
  logic [33:0] dist1__out_dist_sq;
  logic [0:0] dist1__reset;
  logic [15:0] dist1__x1;
  logic [15:0] dist1__x2;
  logic [15:0] dist1__y1;
  logic [15:0] dist1__y2;
  logic [15:0] dist1__z1;
  logic [15:0] dist1__z2;

  EuclideanDistSq3D__nbits_16 dist1
  (
    .clk( dist1__clk ),
    .out_dist_sq( dist1__out_dist_sq ),
    .reset( dist1__reset ),
    .x1( dist1__x1 ),
    .x2( dist1__x2 ),
    .y1( dist1__y1 ),
    .y2( dist1__y2 ),
    .z1( dist1__z1 ),
    .z2( dist1__z2 )
  );

  //-------------------------------------------------------------
  // End of component dist1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dist2
  //-------------------------------------------------------------

  logic [0:0] dist2__clk;
  logic [33:0] dist2__out_dist_sq;
  logic [0:0] dist2__reset;
  logic [15:0] dist2__x1;
  logic [15:0] dist2__x2;
  logic [15:0] dist2__y1;
  logic [15:0] dist2__y2;
  logic [15:0] dist2__z1;
  logic [15:0] dist2__z2;

  EuclideanDistSq3D__nbits_16 dist2
  (
    .clk( dist2__clk ),
    .out_dist_sq( dist2__out_dist_sq ),
    .reset( dist2__reset ),
    .x1( dist2__x1 ),
    .x2( dist2__x2 ),
    .y1( dist2__y1 ),
    .y2( dist2__y2 ),
    .z1( dist2__z1 ),
    .z2( dist2__z2 )
  );

  //-------------------------------------------------------------
  // End of component dist2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component voxelizer
  //-------------------------------------------------------------

  logic [0:0] voxelizer__clk;
  logic [15:0] voxelizer__in_x;
  logic [15:0] voxelizer__in_y;
  logic [15:0] voxelizer__in_z;
  logic [15:0] voxelizer__out_x;
  logic [15:0] voxelizer__out_y;
  logic [15:0] voxelizer__out_z;
  logic [0:0] voxelizer__reset;

  Voxelizer__nbits_16__voxel_bits_4 voxelizer
  (
    .clk( voxelizer__clk ),
    .in_x( voxelizer__in_x ),
    .in_y( voxelizer__in_y ),
    .in_z( voxelizer__in_z ),
    .out_x( voxelizer__out_x ),
    .out_y( voxelizer__out_y ),
    .out_z( voxelizer__out_z ),
    .reset( voxelizer__reset )
  );

  //-------------------------------------------------------------
  // End of component voxelizer
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At C:\Users\samoi\Desktop\Poli\AN_III\AN_III_SEM_I\AC\proiect\clustering_poinclouds\rtl\LidarAccelerator.py:112
  // @update
  // def control_logic():
  //     # Floor removal using voxelized Z
  //     if s.voxelizer.out_z < s.floor_thresh:
  //         s.out_valid @= 0
  //     else:
  //         s.out_valid @= 1
  // 
  //     # Choose closest centroid
  //     if s.dist1.out_dist_sq < s.dist2.out_dist_sq:
  //         s.out_cluster @= 0
  //     else:
  //         s.out_cluster @= 1
  
  always_comb begin : control_logic
    if ( voxelizer__out_z < floor_thresh ) begin
      out_valid = 1'd0;
    end
    else
      out_valid = 1'd1;
    if ( dist1__out_dist_sq < dist2__out_dist_sq ) begin
      out_cluster = 1'd0;
    end
    else
      out_cluster = 1'd1;
  end

  assign voxelizer__clk = clk;
  assign voxelizer__reset = reset;
  assign dist1__clk = clk;
  assign dist1__reset = reset;
  assign dist2__clk = clk;
  assign dist2__reset = reset;
  assign voxelizer__in_x = in_x;
  assign voxelizer__in_y = in_y;
  assign voxelizer__in_z = in_z;
  assign dist1__x1 = voxelizer__out_x;
  assign dist1__y1 = voxelizer__out_y;
  assign dist1__z1 = voxelizer__out_z;
  assign dist1__x2 = c1_x;
  assign dist1__y2 = c1_y;
  assign dist1__z2 = c1_z;
  assign dist2__x1 = voxelizer__out_x;
  assign dist2__y1 = voxelizer__out_y;
  assign dist2__z1 = voxelizer__out_z;
  assign dist2__x2 = c2_x;
  assign dist2__y2 = c2_y;
  assign dist2__z2 = c2_z;

endmodule
